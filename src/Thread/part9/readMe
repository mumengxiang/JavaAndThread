1.本章讲解线程之间的通讯。
   典型：生产者消费者问题
 使用wait() 和notify()方法实现


 wait（）：wait释放锁
 public final void wait() throws InterruptedException
 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。
 当前线程必须拥有此对象监视器。该线程放弃对此监视器的所有权并等待，直到其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。然后该线程将等到重新获得对监视器的所有权后才能继续执行。


 notify（）：
 public final void notify()
 唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。
 直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。



2.sleep和wait的区别
  （1）sleep是Thread的方法，wait是ObjectD的方法
  （2）sleep不会释放锁，wait会释放锁， 进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
  （3）使用sleep不需要定义synchronized方法，而使用wait需要，并且wait还需要依赖monitor。
       见DifferenceWaitAndSleep类
  （4）sleep方法不需要被唤醒，而使用wait需要

  注：定义锁的时候尽量定位为final类型的
  final private static Object Lock = new Object();
